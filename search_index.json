[["index.html", "Introduction to R Programing Table of Contents", " Introduction to R Programing Table of Contents 1. Why R Programming? 2. Installation of Base R and RStudio 3. Exploring R Basics 4. Glossary This is part of the course SCSI 180: Data Literacy for Everyone. Waradon Sungnak, PhD Department of Microbiology Faculty of Science Mahidol University Next: 1. Why R Programming? "],["why-r-programming.html", "1. Why R Programming? 1.1 What’s Special about R? 1.2 R vs. Microsoft Excel 1.3 R vs. Python 1.4 Takeaway", " 1. Why R Programming? 1.1 What’s Special about R? R was developed by statisticians, Ross Ihaka and Robert Gentleman, to specifically cater to the needs of statistical analysis and data visualization. Unlike general-purpose programming languages, R’s core features are designed to handle complex datasets and make it easier to perform tasks like modeling, plotting, and statistical analysis. One of the standout features of R is the tidyverse, a collection of “packages” created by Hadley Wickham and others to make data manipulation, visualization, and analysis more intuitive and consistent. The tidyverse follows a unified approach to data analysis, emphasizing human-readable code and tidy data principles, which make it especially accessible for beginners while being powerful for advanced users. R is also open-source software, meaning it’s free to use and modify. This has allowed a global community of developers to create specialized tools (called “packages” in R) for virtually every area of data science. For example, many tools widely used in biology and bioinformatics—like genome sequencing and gene expression analysis—were developed in R. This makes it an ideal first choice for biologists and biomedical researchers starting their programming journey. 1.2 R vs. Microsoft Excel While Excel is a great tool for small-scale data manipulation and visualization, R offers significant advantages for customization and scalability: Custom Features: In Excel, you’re often limited to built-in formulas and features for basic usage, but in R, you can conveniently write your own functions or use packages to create custom workflows, allowing you to handle more complex tasks much more easily. Professional Visualizations: R allows you to create publication-ready visualizations with packages like ggplot2, which offer greater control over design and aesthetics. BBC Visual and Data Journalism team works with graphics in R Scalability: Excel struggles with very large datasets, often crashing or slowing down with tens of thousands of rows. In R, you don’t need to load the entire dataset into memory at once, as workflows often involve sampling and quality control to efficiently handle even millions of rows of data, provided your computer has sufficient resources. 1.3 R vs. Python The debate between R and Python remains a hot topic in data science. Here’s a simple breakdown: Ease of Use: Python is often considered more intuitive as a general-purpose language, but R, especially with packages like tidyverse, provides a more elegant and structured way to handle data science tasks. Specialized Tools: R is packed with tools designed by statisticians and researchers, making it particularly strong in biology and bioinformatics. Many statistical methods and visualization tools used in bioinformatics/computational biology appear in R first. Flexibility: Python is highly versatile and widely used in areas like web development, AI, and machine learning. For cutting-edge AI tools and modules, Python has a clear edge. R vs Python 1.4 Takeaway Programming languages are just tools. While learning the syntax of a language like R or Python is important, the most critical skill is learning how to think logically and solve problems. If Microsoft Excel is faster and more convenient for you and it’s sufficient to solve your problems, then use Excel. “It doesn’t matter whether a cat is black or white, as long as it catches mice.” - Deng Xiaoping Today, with tools like LLMs (e.g., ChatGPT), you can get assistance writing code in any language so it’s way easier for beginners to navigate through coding, but it’s your ability to define the problem and structure a solution that makes the real difference. What matters most is understanding what you want to achieve and using the right language or tool for the task. What you need to be able to handle is how to define your problem, how to address it in steps, then what tools and functions to use. A lot of the time, the functions will be available in both R and Python—you just need to know the right codes and the right grammar. Think of programming like learning a language. When you want to communicate something, you start with an idea in your head (your problem). Then, you figure out how to express it in words (your steps). Finally, you choose the right vocabulary and grammar (your syntax and functions). Whether you’re speaking English, Thai, or French, as long as you know what you want to say, the language is just the tool you use to express it. Programming works the same way! However, a practical way to learn is to start with one so you know what you can do. Once you’re good at one programming language, learning another is much easier. It’s like learning how to say the same thing in a different language! Some other benefits to know R Programming Many research projects in biomedical science (including mine!) rely on R. If you know even a little R, you can jump into interesting lab work way faster. It looks great on your CV! Having R Programming skills makes you stand out for internships, research projects, and even jobs. You can explore your own data. Imagine being able to analyze and make sense of your own research without waiting for someone else to do it for you. Previous: Table of Contents | Next: 2. Installation of Base R and RStudio "],["installation-of-base-r-and-rstudio.html", "2. Installation of Base R and RStudio 2.1 Why Do We Need Both Base R and RStudio? 2.2 Steps to Install Base R and RStudio", " 2. Installation of Base R and RStudio 2.1 Why Do We Need Both Base R and RStudio? Base R is the engine that runs the R programming language. It’s like the core of the car that makes everything work. RStudio is the user-friendly dashboard that makes working with R easier. It’s like the control panel of the car—making it easier to drive and explore what’s under the hood. 2.2 Steps to Install Base R and RStudio Here’s how to get started: Install Base R: Go to the CRAN website: https://cran.r-project.org/ Choose your operating system: Windows: Download R-X.X.X-win.exe and follow the installation instructions. Mac: Download R-X.X.X.pkg and install it. Linux: Follow the specific instructions for your distribution. Complete the installation. Install RStudio: Visit the RStudio download page: https://posit.co/download/rstudio-desktop/ Download the installer according to your operating system: Windows: Download the .exe file. Mac: Download the .dmg file. Linux: Follow the provided instructions. Install RStudio by running the downloaded file and following the setup process. Again, you need to do both 1&amp;2 for you to be able to work on RStudio. Optional alternative: you don’t need to do this if you do 1&amp;2 already. For iPads or those who don’t want to install software on your device as you will only need a browser like Google Chrome. Use RStudio Cloud: If you’re on an iPad or want to avoid installing RStudio on your device, you can use RStudio Cloud. This is an online version of RStudio that runs in your browser. Go to: https://posit.cloud/ Create a free account and start a new RStudio project. You can upload your scripts and data to the cloud and run R just like you would in the desktop version. We do not recommend working on iPads as there will be lots of typing. Previous: 1. Why R Programming? | Table of Contents | Next: 3. Exploring R Basics "],["exploring-r-basics.html", "3. Exploring R Basics 3.1 Introduction to RStudio Interface 3.2 Start our initial exploration in R 3.3 Variables and Variable Assignment 3.3 Functions in R 3.4 Packages: Extending the Power of R 3.5 Setting up Working Directory 3.6 Types of Variables 3.7 Data Structure in R 3.7 Understanding Dataframes", " 3. Exploring R Basics 3.1 Introduction to RStudio Interface RStudio is a powerful and user-friendly interface for working with R. It simplifies coding and data analysis with its organized layout and handy tools. Here’s a quick tour of the four main panels you’ll use: Console, Script Editor, Environment/History, Plots/Packages/Help/Viewer. 3.1.1 Console (Bottom Left) Purpose: This is where you interact with R directly. You can type commands, press Enter, and see the results immediately. Key Features: The Console only allows line-by-line execution. This means you can type a single command, run it, and see the output right away. For longer scripts or multiple lines of code, you’ll need the Script Editor. Previous commands can be accessed using the up arrow key, so you don’t have to retype them. Error messages and warnings are displayed here, helping you debug your code. Example: Type 2 + 2 and press Enter. You’ll see: 2+2 [1] 4 3.1.2 Script Editor (Top Left) Purpose: A space for writing and saving longer pieces of code, called scripts. Key Features: Write multiple lines of code. Save your script for future use (File &gt; Save as .R file). Run lines of code by selecting them and pressing Ctrl + Enter (Windows) or Cmd + Enter (Mac). Example: Go to File &gt; New File &gt; R Script to open a new script file. Type the following code in the Script: 2 + 2 Highlight the line, then press Ctrl + Enter (Windows) or Cmd + Enter (Mac) to run it. The result will appear in the Console: [1] 4 If you want to save your 2 + 2 work for future use, save the script using File &gt; Save As, which will save it as a .R file that you can reopen later. 3.1.3 Environment/History (Top Right) Environment Tab: Purpose: Shows all the variables, datasets, and objects you’ve created. Example: If you create the following in the Console or Script Editor: x &lt;- 2 + 2 You’ll see x listed in the Environment tab with its value 4. History Tab: Keeps a record of all commands you’ve run in the Console. You can click on any command in the history to re-run or copy it. 3.1.4 Plots/Packages/Help/Viewer (Bottom Right) Plots Tab: Purpose: Displays graphs and visualizations generated by your code. Example: Create a simple plot: plot(1:10) The graph will appear in the Plots tab. Note: If you are working in an R Markdown or R Notebook instead of an R Script, the graph will appear directly in the document output instead of the Plots tab. Packages Tab: Purpose: Manage R packages (install, update, and load them). Example: Install and load the ggplot2 package by running this code: install.packages(&quot;ggplot2&quot;) #installing the package library(ggplot2) #loading the package You should see ggplot2 appear in the Packages tab with a checkmark indicating that it is loaded. Question: What’s the purpose of # the above code? Click here for the answer In R, the # symbol is used to add comments to your code. Comments are lines of text that R ignores when running the code. They’re incredibly useful for explaining what your code does or for leaving notes to yourself or others who may read your script. Help Tab: Purpose: Access documentation and help files for R functions. Importance: The Help Tab is your go-to resource for understanding how R functions work. It provides detailed explanations, examples, and descriptions of arguments. You should always check the documentation when you’re unsure about a function or need clarification on how to use it. This habit will save you time and help you write more accurate and efficient code. Example: Search for help on the mean function by typing ? in front of a function name: ?mean What to Look For in the Help Tab Output: Description: A brief summary of what the function does (e.g., mean calculates the arithmetic mean). Usage: Shows how to write the function and the required inputs (e.g., mean(x, trim = 0, na.rm = FALSE)). Arguments: Describes each input: x: The data to compute the mean from. trim: The fraction of data to exclude from each end (default is 0 if not specified). na.rm: Whether to remove NA values before calculation (default is FALSE if not specified). Default Arguments: Defaults save you time by providing pre-set values for arguments. For example: If you don’t specify trim, it assumes 0. If you don’t specify na.rm, it assumes FALSE. You only need to include these arguments if you want to override the defaults. Value: Explains the output of the function Examples: Examples of code snippets to see the function in action Pro Tip: Always check the Arguments section to understand the defaults, and look at the Examples section to see how the function is typically used. Viewer Tab: Purpose: View web-based outputs, such as interactive graphs or HTML reports. 3.2 Start our initial exploration in R Excercise 1. Find the square root of 1024 using R. Hint: Use the sqrt() function 2. What happens when you run the following code? print(&quot;Hello, World!&quot;) Click for Answer [1] &quot;Hello, World!&quot; 3. Consider the following code: x &lt;- 42 x x &lt;- 43 x Question: What is the value of x after the last line? Click for Answer [1] 43 4. Consider the following code: y &lt;- 10 z &lt;- x + y z Question: What is the value of z? Challenge: Change the value of y to 20 and recalculate z. What happens to z? Click for Answer [1] 53 The value of z will be 63 after changing the value of y to 20. 5. What happens if you try assigning a value to a variable using = instead of &lt;-? x = 10 x Click for Answer In R, both = and &lt;- can be used for variable assignment. However, &lt;- is preferred in R because: It’s the standard syntax used in most R code, making it easier to read and consistent across scripts. It avoids confusion with = used in function arguments. Example: # Using `=` for variable assignment: x = 10 print(x) ## [1] 10 # Using `=` inside a function argument: mean(x = c(1, 2, 3)) # `x` is a parameter that we will pass a value (known as an argument) to to the mean function. X here is not a variable. ## [1] 2 What’s the difference between what we did to x here? # Preferred approach to avoid confusion: x &lt;- 10 # Assign 10 to variable x print(x) ## [1] 10 mean(x = c(1, 2, 3)) # Use x as input for the mean function ## [1] 2 We will learn more about the distinction later once we cover the concepts of variables and functions. 3.3 Variables and Variable Assignment What is a variable? A variable in R is a container that stores a value (e.g., a number, text, or dataset) for future use. Think of it as a labeled box where you can put things and retrieve them later. How to assign a value to a variable In R, you assign a value to a variable using &lt;- (preferred). Examples: # Assigning values using `&lt;-` x &lt;- 10 y &lt;- &quot;Hello, R&quot; Now you can retrieve the stored values later. # Assigning values using `&lt;-` print(x) ## [1] 10 print(y) ## [1] &quot;Hello, R&quot; Variable naming Rules Can contain: Letters, numbers, underscores (_), and dots (.). Must start with: A letter or a dot (not followed by a number). Cannot contain: Spaces or special characters (@, #, etc.). Case-sensitive: myVar and MyVar are different variables. Quiz: Is it a valid variable name in R? For each example below, determine whether it’s a valid variable name in R. Write down Yes or No for each. my_var 2cool .hiddenValue total.sales hello world data#123 _underscore abc_123 .1startingWithDot CaseSensitive vs casesensitive Click here for the answers Key: valid variable names my_var → Yes 2cool → No (Starts with a number) .hiddenValue → Yes total.sales → Yes hello world → No (Contains a space) data#123 → No (Contains a special character #) _underscore → No (Cannot start with an underscore) abc_123 → Yes .1startingWithDot → No (Dot followed by a number) CaseSensitive vs casesensitive → Both are valid but different variables (Case-sensitive). Exercise Copy and paste the following code into your R Script, run it, and answer the questions. # Assign values to variables a &lt;- 50 b &lt;- 100 # Perform operations with variables c &lt;- a + b c # Modify a variable a &lt;- a * 2 a Questions: What is the value of c? What happens to a after you modify it? Can you create a variable named 1a? Why or why not? Pro Tip: Use descriptive variable names Choose meaningful names for variables to make your code easier to understand. total_sales &lt;- 1000 # Clear and descriptive x &lt;- 1000 # Ambiguous 3.3 Functions in R What’s a function? A function in R is a block of code that performs a specific task. Functions help you reuse code and simplify your work by performing complex operations with just a single line. Why use functions? Efficiency: Avoid rewriting code for repetitive tasks. Clarity: Make your code easier to read and understand. Modularity: Break your work into smaller, reusable pieces. How functions work Functions take inputs (called arguments) and return outputs. These inputs are specified in the function as parameters, which act as placeholders for the values you provide. When calling a function, you match parameters to arguments. Structure of a function function_name(parameter = argument) Examples of built-in functions that come with base R Math functions sqrt(16) # Square root of 16 ## [1] 4 log(100, 10) # Logarithm base 10 of 100 ## [1] 2 Statistical functions mean(c(1, 2, 3, 4, 5)) # Average of numbers ## [1] 3 sum(1:10) # Sum of numbers 1 to 10 ## [1] 55 String functions tolower(&quot;HELLO&quot;) # Convert to lowercase ## [1] &quot;hello&quot; toupper(&quot;hello&quot;) # Convert to uppercase ## [1] &quot;HELLO&quot; Creating your own function You can define your own function in R using the function keyword. NOTE THE SPECIFIC CODE STRUCTURE Structure of a function creation function_name &lt;- function(x, y, ...) { Steps of things you want to do with the inputs x, y, ... } Example # Define a function to calculate the square of a number square &lt;- function(x) { return(x^2) } In the above code, we create a function called square(), which takes an argument assigned to a parameter x. When the function is called, the action specified in {} is performed using the provided argument. Calling the function # Use the function square(5) # Output: 25 ## [1] 25 Here: 5 is the argument passed to x when the function is called. The result of x^2 is returned as the output. 3.4 Packages: Extending the Power of R What is a package? Normally, for beginners, we don’t frequently have to write our own functions. Instead, we can use functions that others have already created and shared through packages, saving our time and effort. A package is a collection of R functions, datasets, and documentation bundled together for a specific purpose. Think of it as an “add-on” that provides tools tailored to your needs. Why use packages? Packages let you use functions that aren’t built into base R. They save time by providing pre-written code for common tasks. They’re widely used for tasks like plotting (ggplot2), data manipulation (dplyr), or bioinformatics (Bioconductor packages). Installing and loading packages Install a package Use the install.packages() function to download and install a package. Note: Package names go inside quotes (\"\") when using install.packages(). Not all packages can be installed this way and may require alternative installation methods. Check the documentation for that specific package if you encounter issues during installation by simply google it. Example: install.packages(&quot;dplyr&quot;) # Install a package called dplyr. Note the quotation. Load a package Use the library() function to load a package into your R session. This is like open the software you’d like to use here. Note: Package names do NOT need quotes when using library(). Example: library(dplyr) # Load the package dplyr. No quotation here. Check Installed Packages See all installed packages in the Packages Tab (Bottom Right of RStudio). Use installed.packages() in the console to list them: installed.packages() Starting with library() in R Scripts Typically, when you see an R Script shared by others, it will start with a section that loads all the necessary packages using library(). This ensures that all the tools needed for the script are available. Why? If you’d like to replicate the script, you can simply copy and paste it, and everything should work as long as the required packages are installed. What if it doesn’t? If you encounter an error, it usually means the package isn’t installed. You just need to install it, often using install.packages(\"package_name\"), and you’re good to go. Reminder: You only need to install a package once, but you must load it with library() every session. Example # This is the beginning of a script. We will load required packages. library(ggplot2) # For advanced plotting library(dplyr) # For data manipulation library(tidyr) # For tidying data library(readr) # For reading CSV files #Now we can start getting our hands dirty! Note that the above packages are parts of tidyverse. You can simply install and load the tidyverse package instead. Example library(tidyverse) 3.5 Setting up Working Directory The challenges of command-line interfaces When working with R, you’ll notice a big shift compared to how we usually interact with computers. In R programming, you’ll primarily use typed commands to perform actions, unlike the clicking and dragging you’re used to in Graphical User Interface (GUI). This text-based interactive approach is known as a Command-Line Interface (CLI). Imagine you’re writing a document in MS Word. You don’t need to think much about where your file is saved—you just click “Insert” to add an image from a gallery of icons and save the document wherever you like, often with just a few clicks. Later, you can simply drag and drop files around your desktop to organize them. In CLIs, things are more structured but less forgiving. You must be aware of where you are working because when you save a file, it’s saved in your current working directory. If you don’t specify where to save or open files, R assumes it should look in or save to this directory. If you aren’t mindful of this, errors like File not found or misplaced outputs can occur. What’s a directory? For a beginner, you can assume a directory as simply a folder on your computer that holds files and subfolders. Directories help you organize your work and locate files easily. In R, directories are critical because they determine where your input files (like datasets) are read from and where output files (like results or plots) are saved. What’s different from what you’re used to is that, instead of navigating through your screen by clicking and dragging folder icons to access files, you’ll now access files by specifying a path through typing. For example, on Windows, if you want to access a file called homework1.docx in the Documents folder, you would specify its path as C:/Users/YourName/Documents/homework1.docx. Types of directories When working in R, directories play a crucial role in managing your files. Understanding the difference between Home Directory and Working Directory will help you avoid common pitfalls when reading or saving files. 1. Home Directory: The starting point or default location on your computer. Example: C:/Users/YourName/Documents (Windows) or /Users/YourName (Mac). The home directory is often used as a reference point and can be accessed in R using the shortcut ~, so you don’t need to type the whole path. Example: If your home directory is C:/Users/YourName/Documents (default for R on Windows), and you want to access a file called homework1.docx, instead of typing: &quot;C:/Users/YourName/Documents/homework1.docx&quot; You can simply type: &quot;~/homework1.docx&quot; This makes navigating files faster and avoids lengthy path names. Pro Tip: If you’re used to using ~ as a shortcut for switching languages (e.g., keyboard input), this might give you a headache when working in a Command-Line Interface (CLI). In R, ~ has a specific meaning as the home directory path. 2. Working Directory: The folder R is currently using to read or save files. Think of it as the “active folder” for your current R session. You can change the working directory as needed to organize files for a specific project. If not, your home directory will be your working directory. Example: setwd(&quot;~/Projects/MyAnalysis&quot;) It’s good practice to set up a unique working directory for each project to keep input files and outputs well-organized. Setting up a working directory in R 1. Check Your Current Directory: Use the getwd() function (“get working directory”) to check your current working directory: getwd() 2. Set a New Working Directory: Use the setwd() function (“set working directory”) to change the working directory to another specific folder you already have: setwd(&quot;~/MyProject&quot;) You can check if the working directory has change by running getwd() again. getwd() Exercise: Create a folder called SCSI180_Project in your Documents. Then, make the folder SCSI180_Project your working directory. 3.6 Types of Variables Now let’s go back to variables. As we learned previously, variables are containers for storing values. These values can take different forms, depending on the type of data being stored. Understanding these variable types is crucial because it determines how you can manipulate and use the data in calculations or functions. Common Variable Types in R 1. Numeric: integer, double 2. Character 3. Logical 4. Factor You can use these functions to check the type of a variable: class(): Tells you the type of the variable. typeof(): Provides a more technical description of the data type. 1. Numeric: R stores numeric data as either integers or doubles. Integer: Whole numbers without decimals. x &lt;- 10L typeof(x) ## [1] &quot;integer&quot; Appending an uppercase L to a numeric value is a way to explicitly make it an integer. Otherwise, it will be a double by default. Double: Floating-point numbers (numbers with decimals). By default, R treats all numeric data as doubles unless specified as integers with appending L. y &lt;- 3.14 typeof(y) ## [1] &quot;double&quot; Note: Unlike some programming languages, R does not have a separate “float” type. 2. Character: Represents text, often referred to as strings, which are sequences of characters enclosed in quotes. name &lt;- &quot;Alice&quot; greeting &lt;- &quot;Hello, World!&quot; print(name) ## [1] &quot;Alice&quot; print(greeting) ## [1] &quot;Hello, World!&quot; typeof(name) ## [1] &quot;character&quot; Pro Tip: Strings can use either single (') or double (\") quotes, but they must match. 3. Logical: Represents TRUE or FALSE values, often used in conditions or comparisons. Generally equivalent to what is commonly known as a boolean in other programming languages. is_valid &lt;- TRUE is_greater &lt;- 5 &gt; 3 print(is_valid) ## [1] TRUE print(is_greater) ## [1] TRUE typeof(is_greater) ## [1] &quot;logical&quot; Quiz: 3.1 Run the following code: a &lt;- 5 == 8 typeof(a) What is the output of typeof(a)? What does 5 == 8 evaluate to? 3.2 What is the difference between = and == in R? Click here for the answers 3.1 Output of typeof(a): The output is \"logical\". Explanation: The comparison 5 == 8 evaluates to FALSE because 5 is not equal to 8. The variable a is assigned this logical value, and typeof(a) confirms its type as logical. 3.2 Difference Between = and ==: = is used for variable assignment, similar to &lt;-, though it’s not the preferred method in R Example: x = 10 # Assigns 10 to x (not preferred) x &lt;- 10 # Assigns 10 to x (preferred) = is also used to specify arguments to parameters in functions. Example: mean(x = c(1, 2, 3)) # Assigns the vector c(1, 2, 3) to the parameter x ## [1] 2 == is used for comparison. It checks if two values are equal and returns a logical result (TRUE or FALSE). Example: 5 == 8 # Returns FALSE ## [1] FALSE Key Takeaway: Use == for comparisons Use &lt;- (preferred) or = for variable assignments Use = when specifying arguments in function calls to avoid confusion 4. Factor: Represents categorical/discrete data with fixed levels, like a dropdown list with pre-defined options. gender &lt;- factor(c(&quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;)) gender ## [1] Male Female Male ## Levels: Female Male Why use factors? They ensure consistency in categorical data and are more memory efficient. 3.7 Data Structure in R Now that we’ve covered variable types, let’s explore how data is organized and stored in R. R provides various data structures to handle collections of data. The three most commonly used are: 1. Vectors 2. Dataframes 3. Lists 1. Vector A vector is a simple, one-dimensional collection of data, where all elements must be of the same type (e.g., numeric, character, logical). Think of it as a column of values in a spreadsheet. The c() function (short for “combine”) is used to create vectors in R by combining individual values into a single structure. Example: # Numeric vector num_vec &lt;- c(1, 2, 3, 4, 5) # Character vector char_vec &lt;- c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;) # Logical vector log_vec &lt;- c(TRUE, FALSE, TRUE) Question: What happen if you try to do this? mixed_vec &lt;- c(1, &quot;Apple&quot;, TRUE) Click here for the Answer When you use c() to combine values of different types, R will automatically coerce them to the same type. In this case: 1 (numeric) and TRUE (logical) will be converted to character to match \"Apple\". Result: print(mixed_vec) ## [1] &quot;1&quot; &quot;Apple&quot; &quot;TRUE&quot; Note that 1 and TRUE are now \"1\" and \"TRUE\": as strings/character. 2. Dataframe A dataframe is a two-dimensional structure, like a table, where data is organized into rows and columns. Each column can store data of a single type (e.g., numeric, character, or logical), but different columns can store different types of data. Think of it as an Excel spreadsheet: Each column is like a variable that holds data of the same type. Each row is like an observation, representing one entry in the dataset. You also can think of a dataframe as a collection of vectors combined as columns: Each column is a vector. You combine multiple vectors (of the same length) to create a dataframe. Example: df &lt;- data.frame( Name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), # Character vector Age = c(25, 30, 35), # Numeric vector Passed = c(TRUE, FALSE, TRUE) # Logical vector ) print(df) ## Name Age Passed ## 1 Alice 25 TRUE ## 2 Bob 30 FALSE ## 3 Charlie 35 TRUE You can extract a column (which is essentially a vector) from a dataframe using the $ operator as dataframe_name$column_name print(df$Name) ## [1] &quot;Alice&quot; &quot;Bob&quot; &quot;Charlie&quot; typeof(df$Name) #This should be a character vector ## [1] &quot;character&quot; 3. List A list is a flexible data structure that can store a collection of elements of different types, including vectors, data frames, and even other lists. Think of it as a box where each item can be completely different. # Create a list my_list &lt;- list( Name = &quot;Alice&quot;, Scores = c(90, 85, 88), Details = data.frame(Subject = c(&quot;Math&quot;, &quot;Science&quot;), Grade = c(&quot;A&quot;, &quot;B&quot;)) ) print(my_list) ## $Name ## [1] &quot;Alice&quot; ## ## $Scores ## [1] 90 85 88 ## ## $Details ## Subject Grade ## 1 Math A ## 2 Science B 3.7 Understanding Dataframes Remember our previous discussion on the power of tabular data? Dataframes in R are a highly organized way to handle tabular data, following specific rules for structure and consistency. Let’s break down their design and focus on how rows and columns are arranged and utilized. Understanding dataframes: Rows vs. Columns Imagine you’re conducting a survey where each person fills out a form with information like their age, gender, occupation, and favorite color. Here’s how the data would look in a dataframe: Rows: Each row represents one individual. Diana fills out the first row. David fills out the second row. And so on, with each row capturing data entry about one person. Example: Name Age Gender Occupation Favorite Color Diana 25 Female Engineer Blue David 30 Male Teacher Green Rows: the Individualist View on All Characteristics When you look at a single row, you’re seeing data about one individual. It’s like learning about a single person’s characteristics. For example: Row #1: Diana, 25, Female, Engineer, Blue. This is all about one person, Diana, with her all characteristics. Row #2: David, 30, Male, Teacher, Green. Similarly, this is all about David. This is an individualist view, but in data science, we’re rarely interested in just one person’s data. Instead, we look for patterns across the group. Columns: the Collective View of Each Characteristic In data science, the focus is typically on columns of a dataframe because: A column represents one characteristic (also known as variable or feature) across the entire group. Columns help us identify patterns and relationships. Example: The Favorite Color column tells us the preferred colors of all surveyed people. By focusing on this column, you can answer questions like: “What is the most common favorite color?” “How does favorite color relate to occupation?” This column-centric thinking is at the heart of data analysis, allowing us to uncover trends and connections in the data. Takeaway Columns are the backbone of how we think about dataframes in analysis. They help us uncover patterns and relationships within the data, providing insights into the group as a whole. Start with the columns, and let the data tell you the story of the group! Exercise: Working with Dataframes Let’s practice creating and manipulating dataframes in R. Try to complete these tasks on your own first. Refer to the examples from the previous section if you need help. Exercise 1. Create a dataframe named survey.1 using the following data: Name Age Gender Occupation Favorite Color Diana 25 Female Engineer Blue David 30 Male Teacher Green Create individual vectors for each column. Combine these vectors into a dataframe named survey.1. 2. Extract the Occupation column from survey.1 and assign it to a new variable called job. 3. Add a new column to survey.1 for Country with the values \"USA\" and \"Canada\". Click here for the answers (only after trying the tasks yourself!) Answers 1. Create a dataframe: # Create vectors Name &lt;- c(&quot;Diana&quot;, &quot;David&quot;) Age &lt;- c(25, 30) Gender &lt;- c(&quot;Female&quot;, &quot;Male&quot;) Occupation &lt;- c(&quot;Engineer&quot;, &quot;Teacher&quot;) Favorite_Color &lt;- c(&quot;Blue&quot;, &quot;Green&quot;) # Combine vectors into a dataframe survey.1 &lt;- data.frame(Name, Age, Gender, Occupation, Favorite_Color) # View the dataframe survey.1 ## Name Age Gender Occupation Favorite_Color ## 1 Diana 25 Female Engineer Blue ## 2 David 30 Male Teacher Green 2. Extract the occupation column: # Extract the Occupation column job &lt;- survey.1$Occupation # View the result job ## [1] &quot;Engineer&quot; &quot;Teacher&quot; 3. Add a new column: # Add a new column survey.1$Country &lt;- c(&quot;USA&quot;, &quot;Canada&quot;) # View the updated dataframe survey.1 ## Name Age Gender Occupation Favorite_Color Country ## 1 Diana 25 Female Engineer Blue USA ## 2 David 30 Male Teacher Green Canada Important Note on Dataframes When working with dataframes, it’s essential to understand the terminology commonly used in data science: An individual or row is often referred to as an observation. Each observation represents one entry in your dataset, such as a person or an event. A column or characteristic is typically called a variable or feature. Each variable represents a specific attribute that is measured or recorded across all observations. Avoiding Confusion: Variables in Dataframes vs. Variables in Basic R In data science, the term “variable” within a dataframe context refers to a column of data (e.g., age, gender, income). However, in basic R programming, a “variable” refers to a named object that stores a value or data structure (e.g., x &lt;- 10). Example: In a dataframe, the column Age is called a variable because it represents a characteristic across all observations. In basic R, when you assign Age &lt;- c(25, 30), Age is a variable in the programming context that stores a vector. Key Takeaway: When working with dataframes, think of variables as columns that represent characteristics or features. In R programming generally, think of variables as containers that hold data. Keep this distinction in mind to avoid confusion as you work with data! Previous: 2. Installation of Base R and RStudio | Table of Contents | Next: 4. Glossary "],["glossary.html", "4. Glossary Interfaces R Programming Basics Directories Data Types Data Structures Dataframe Terminology Operators Exercise", " 4. Glossary Here’s a quick reference to key terms we’ve covered in this session: Interfaces Graphical User Interface (GUI): Interaction with the computer using visual elements like buttons and menus. Example: Clicking “File &gt; Open File” in RStudio. Command-Line Interface (CLI): Interaction with the computer by typing commands instead of using graphical elements. Example: Typing getwd() in RStudio to print the current working directory. R Programming Basics Variable: A named container that stores data in R. Example: x &lt;- 10 Function: A block of reusable code that performs a specific task. Functions take inputs (arguments) and return outputs. Example: sqrt(16) calculates the square root of 16. Parameter: A placeholder in a function definition that accepts input values. Parameters are defined in the function header. Example: In the function mean(x, na.rm = FALSE), x and na.rm are parameters. Argument: The actual values provided to a function when it is called. Arguments are passed to the parameters. Example: In mean(x = c(1, 2, 3), na.rm = TRUE), c(1, 2, 3) is the argument for the parameter x, and TRUE is the argument for the parameter na.rm. Package: A collection of pre-built R functions, datasets, and documentation designed for specific tasks. Packages extend R’s capabilities. Example: ggplot2 for advanced data visualization. Directories Home Directory: The default starting location on your computer for files. Example: C:/Users/YourName/Documents Working Directory: The folder R is currently using to read or save files. Example: Set with setwd(\"path/to/folder\"). Data Types Numeric: Represents numbers (e.g., integers or doubles). Character: Text or strings enclosed in quotes. Example: \"Hello, World!\" Logical: Two-valued/binary/Boolean variables - either TRUE or FALSE, often used in conditions or comparisons Factor: Categorical data with fixed levels. Example: factor(c(\"Male\", \"Female\")) Data Structures Vector: A one-dimensional collection of data of the same type. Example: c(1, 2, 3) Dataframe: A two-dimensional structure with rows (observations) and columns (variables). Example: data.frame(Name = c(&quot;Alice&quot;, &quot;Bob&quot;), Age = c(25, 30)) List: A flexible collection that can store data of different types. Example: list(Name = \"Alice\", Scores = c(90, 85)) Dataframe Terminology Observation: A row in a dataframe representing an individual entry. Variable/Feature: A column in a dataframe representing a specific characteristic. Operators &lt;-: Used to assign values to variables (preferred over =). =: Also used for assignment or to specify arguments in functions. ==: Comparison operator to check equality. Exercise 1. You downloaded a file called data.csv from the internet and ran the following code: read.csv(&quot;data.csv&quot;) However, you get an error saying file not found. What might be causing this issue, and how can you fix it? Click for Answer Possible causes: The file data.csv is not in your current working directory. Check with getwd() and move the file there or specify the full path. The filename may have a typo or incorrect capitalization. The file extension .csv might be missing or incorrect. Solutions: Use getwd() to confirm the working directory. Verify the filename and path. If the file is in another location, use setwd() or provide the full path, e.g., read.csv(\"C:/Users/YourName/Documents/data.csv\"). 2. In the function mean(x = c(1, 3, 5), na.rm = TRUE): Identify the parameters. Identify the arguments. Click for Answer Parameters: x, na.rm Arguments: c(1, 3, 5) is the argument for x; TRUE is the argument for na.rm. 3. What is the data structure of c(12.5, 15.0, 20.0) and what will be the output of the following code? typeof(c(12.5, 15.0, 20.0)) Click for Answer The data structure is a numeric vector. The output of typeof(c(12.5, 15.0, 20.0)) will be \"double\". 4. What will be the output of the following code? fruits &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) fruits[4] &lt;- &quot;date&quot; print(fruits) Click for Answer The output will be: [1] &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot; &quot;date&quot; Explanation: The fruits vector was extended to include “date” at index 4. 5. What’s the output of the following code and what are the differences of x as variables in these two different contexts? x &lt;- c(1, 2, 3) df &lt;- data.frame(x = c(4, 5, 6)) print(x) print(df$x) Click for Answer The output will be: print(x) [1] 1 2 3 print(df$x) [1] 4 5 6 Explanation: x as a variable in R: A named container that stores data in R. Here, x is a standalone vector holding three numeric values: 1, 2, and 3. x as a variable/feature in a dataframe: A column in the dataframe df that represents a specific characteristic. It is tied to the dataframe and must be accessed with df$x. Key Difference: x as a standalone variable and x as a column in a dataframe are both referred to as variables but differ in context. In a dataframe, variables or features are stored in columns, which collectively describe given characteristics in a dataset. 6. What will the following code output and what’s the difference between = and == here? x = 3 print(x) print(x = 4) print(x == 3) Click for Answer Output: print(x): [1] 3 print(x = 4): [1] 4 print(x == 3): [1] TRUE Explanation: = for assignment (though &lt;- is preferred in R): x = 3 assigns the value 3 to the variable x. x = 4 inside print() temporarily assigns 4 to x and returns it, but this does not persist. After this line, x still holds the value 3. == for comparison: x == 3 checks whether the value of x is equal to 3 and returns TRUE since x was assigned 3 earlier. Key Difference: = is used to assign a value to a variable. == is used to compare values, returning TRUE if they are equal or FALSE otherwise. Table of Contents | Previous: 3. Exploring R Basics "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
